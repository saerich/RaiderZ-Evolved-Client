/*
* Copyright 2010 Autodesk, Inc.  All rights reserved.
* Use of this software is subject to the terms of the Autodesk license agreement provided at the time of installation or download, 
* or which otherwise accompanies this software in either electronic or hard copy form.
*/

	


/*!	\file
	\ingroup kypathdata_basesystem */

#ifndef KY_LOGGER_H
#define KY_LOGGER_H

#if !defined(__SPU__)

#include <kypathdata/generic/ilogbridge.h>
#include <kypathdata/basesystem/threadlocalstorage.h>

namespace Kaim
{

class LoggerImplementation;

/*!	This class handles debug messages generated by \SDKName components in the Debug build of the
	\SDKName libraries.
	\pp When you open the Engine using the Debug libraries, an instance of this class is created
	automatically and maintained by the BaseSystem. This instance is accessible at any time by calling 
	the static Logger::GetInstance() function. Whenever a component
	within the \SDKName Engine calls the #KY_MESSAGE, #KY_COND_MESSAGE or #KY_ASSERT macro to send
	a debug message, the message is sent \em via this instance of Logger to the implementation of
	the ILogBridge interface served by the Bridge.
	\pp Use of this class is entirely transparent in most cases. To log messages through this debug
	manager from your custom components, invoke the #KY_MESSAGE, #KY_COND_MESSAGE and #KY_ASSERT
	macros.
	\pp However, you may make use of the Logger instance accessible through Logger::GetInstance()
	in order to configure or limit the types of messages that may be logged through the ILogBridge
	interface. See the Logger class methods for details.
	\pp See also :USERGUIDE:"Working With Debug Messages".
	\ingroup kypathdata_basesystem */
class Logger
{
	typedef ThreadLocalStorageWrapper<Logger*> TlsLogger;

	KY_DEFINE_NEW_DELETE_OPERATORS

public:
	/*!	Retrieves the instance of the Logger created by the BaseSystem during its initialization
		of the \SDKName Engine. */
	static Logger* GetInstance();

	/*!	Terminates the Logger. For internal use. */
	static void TerminateInstance();

	static void TerminateExplicitInstance(Logger* instance)
	{
		KY_DELETE_CLASS(instance);
	}

	static TlsLogger& GetTls()
	{
		static TlsLogger tlsLogger;
		return tlsLogger;
	}

public:
	/*!	\label_constructor For internal use. */
	Logger() : m_impl(KY_NULL) { }

	/*!	\label_destructor For internal use. */
	~Logger() { Terminate(); }

public:
	/*!	\label_init For internal use. */
	KyResult Init();

	/*!	Terminates the Logger. For internal use. */
	void Terminate();

	/*!	Indicates whether or not the Logger has been successfully initialized. */
	bool IsInitialized() const { return m_impl != KY_NULL; }

public:
	/*!	Disables all messages of the specified type. The type may be any element from the #LogLevel enumeration. */
	KyBool Disable(LogLevel logLevel);

	/*!	Re-enables all messages of the specified type. The type may be any element from the #LogLevel enumeration. */
	KyBool Enable(LogLevel logLevel);

	/*!	Re-enables all messages with the specified ID. */
	KyBool EnableId(KyUInt32 id);

	/*!	Disables all messages with the specified ID. */
	KyBool DisableId(KyUInt32 id);

	/*!	Limits the number of times the Logger will generate a message with the specified ID. */
	KyBool EnableMaxCall(KyUInt32 id, KyUInt32 maxCall, KyBool overwrite = KY_TRUE);

	/*!	Removes any limits previously set for messages with the specified ID through a call to EnableMaxCall(). */
	KyBool DisableMaxCall(KyUInt32 id);

	/*!	Disables the Logger entirely. */
	void Disable();

	/*!	Re-enables the Logger. */
	void Enable();

	/*! Resets the call counter to zero for messages with the specified ID. */
	KyBool ResetCallCounter(KyUInt32 id);

	/*! Resets the call counter to zero for all messages. */
	KyBool ResetAllCallCounter();

public:
	/*!	@{ */
	/*!	For internal use. These functions are used in macros. */
	char* GetBuffer();

	void CreateMessage(const char* format, ...);

	void Print(
		LogLevel logLevel,
		KyUInt32 id,
		const char* fileName, 
		const KyUInt32 lineNum,
		const char* functionName);

	void PrintWithPrefix(
		LogLevel logLevel,
		KyUInt32 id,
		const char* fileName,
		const KyUInt32 lineNum,
		const char* functionName,
		const char* prefix);

	KyUInt32 ComputeMessageId2(const char* condition, const char* args);

	KyUInt32 ComputeMessageId(const char* format, ...);

	KyBool SetLastMsgMaxCall(KyUInt32 maxCall);

	KyBool SetLastMsgMaxCallWithWarning(KyUInt32 maxCall);

	void StartNewMessage();
	/*!	@} */

private:
	const char* Sprintf(const char* format, ...);

private:
	LoggerImplementation* m_impl;
};


}


#if defined(_MSC_VER) && (defined (KY_WINDOWS_ANY) || defined (KY_XBOX360))
#define KY_MACRO_START	do {                         \
	KY_PRAGMA(warning(push))                         \
	KY_PRAGMA(warning(disable:4127))
#define KY_MACRO_END	} while(0)                   \
	KY_PRAGMA(warning(pop))
#else
#define KY_MACRO_START	do {
#define KY_MACRO_END	} while(0)
#endif


#if defined (KYDEBUG)

/*!	Generates a debugging message.
	\param logLevel					Indicates the type of message to generate. May be any element from the 
									#LogLevel enumeration.
	\param args						The content of the message to generate. The message should be enclosed in
									parentheses, and may include variables using the standard C++ string
									printing syntax.
	\pp In order to use this macro, you must have already called #KY_FUNCTION within the same code block.
	\pp For example: \code
	KY_FUNCTION("MyFunctionName");
	...
	KY_MESSAGE(KY_LOG_WARNING, ("Invalid value for parameter [%s]", paramName)); \endcode
	\ingroup kypathdata_basesystem */
#define KY_MESSAGE(logLevel, args)                                                                             \
KY_MACRO_START                                                                                                 \
	Kaim::Logger* logger = Kaim::Logger::GetInstance();                                                        \
	if (logger != KY_NULL && logger->IsInitialized())                                                          \
	{                                                                                                          \
		logger->StartNewMessage();                                                                             \
		static const KyUInt32 s_id = logger->ComputeMessageId args;                                            \
		logger->CreateMessage args;                                                                            \
		logger->Print(logLevel, s_id, __FILE__, __LINE__, s_KY_funcName);                                      \
	}                                                                                                          \
KY_MACRO_END

#ifdef KY_WII // Don't use static on Wii

#define KY_COND_MESSAGE(logLevel, condition, args)                                                             \
do {                                                                                                           \
	Kaim::Logger* logger = Kaim::Logger::GetInstance();                                                        \
	if (logger != KY_NULL && logger->IsInitialized())                                                          \
	{                                                                                                          \
		logger->StartNewMessage();                                                                             \
		if (!Kaim::IsFalse(condition))                                                                         \
		{                                                                                                      \
			const KyUInt32 s_id = logger->ComputeMessageId args;                                               \
			logger->CreateMessage args;                                                                        \
			logger->Print(logLevel, s_id, __FILE__, __LINE__, s_KY_funcName);                                  \
		}                                                                                                      \
	}                                                                                                          \
} while (Kaim::IsFalse(true))

#define KY_ASSERT(condition, args)                                                                             \
do {                                                                                                           \
	Kaim::Logger* logger = Kaim::Logger::GetInstance();                                                        \
	if (logger != KY_NULL && logger->IsInitialized())                                                          \
	{                                                                                                          \
		logger->StartNewMessage();                                                                             \
		if (Kaim::IsFalse(condition))                                                                          \
		{                                                                                                      \
			const KyUInt32 s_id = logger->ComputeMessageId2(#condition, #args);                                \
			logger->CreateMessage args;                                                                        \
			logger->PrintWithPrefix(Kaim::KY_LOG_ASSERT, s_id, __FILE__, __LINE__, s_KY_funcName, #condition);       \
		}                                                                                                      \
	}                                                                                                          \
} while (Kaim::IsFalse(true))

#else // !KY_WII...

/*!	Generates a debugging message only if a specified condition is met.
	\param logLevel					Indicates the type of message to generate. May be any element from the 
									#LogLevel enumeration.
	\param condition				The condition to evaluate. If this condition evaluates to true, the message
									is sent. If not, the message is not sent.
	\param args						The content of the message to generate. The message should be enclosed in
									parentheses, and may include variables using the standard C++ string
									printing syntax.
	\pp In order to use this macro, you must have already called #KY_FUNCTION within the same code block.
	\pp For example: \code
	KY_FUNCTION("MyFunctionName");
	...
	KY_COND_MESSAGE(KY_LOG_ERROR, file==KY_NULL, ("Could not open file [%s]", fileName));  \endcode
	\ingroup kypathdata_basesystem */
#define KY_COND_MESSAGE(logLevel, condition, args)                                                            \
KY_MACRO_START                                                                                                \
	if (condition)                                                                                            \
	{                                                                                                         \
		KY_MESSAGE(logLevel, args);                                                                           \
	}                                                                                                         \
	else                                                                                                      \
	{                                                                                                         \
		Kaim::Logger* logger = Kaim::Logger::GetInstance();                                                   \
		if (logger != KY_NULL && logger->IsInitialized())                                                     \
		{                                                                                                     \
			logger->StartNewMessage();                                                                        \
		}                                                                                                     \
	}                                                                                                         \
KY_MACRO_END

/*!	Generates a debugging message of type #KY_LOG_ASSERT if a specified condition is not met.
	\param condition				The condition to evaluate. If this condition evaluates to false, the assert
									message is sent. If this condition evaluates to true, no message is sent
									and execution of the code continues.
	\param args						The content of the message to generate. The message should be enclosed in
									parentheses, and may include variables using the standard C++ string
									printing syntax.
	\pp In order to use this macro, you must have already called #KY_FUNCTION within the same code block.
	\pp For example: \code
	KY_FUNCTION("MyFunctionName");
	...
	KY_ASSERT(ori!=Vector::s_nullVector, ("Invalid orientation for entity [%s]", m_name));  \endcode
	\ingroup kypathdata_basesystem */
#define KY_ASSERT(condition, args)                                                                               \
KY_MACRO_START                                                                                                   \
	if (!(condition))                                                                                            \
	{                                                                                                            \
		Kaim::Logger* logger = Kaim::Logger::GetInstance();                                                      \
		if (logger != KY_NULL && logger->IsInitialized())                                                        \
		{                                                                                                        \
			logger->StartNewMessage();                                                                           \
			static const KyUInt32 s_id = logger->ComputeMessageId2(#condition, #args);                           \
			logger->CreateMessage args;                                                                          \
			logger->PrintWithPrefix(Kaim::KY_LOG_ASSERT, s_id, __FILE__, __LINE__, s_KY_funcName, #condition);   \
		}                                                                                                        \
	}                                                                                                            \
	else                                                                                                         \
	{                                                                                                            \
		Kaim::Logger* logger = Kaim::Logger::GetInstance();                                                      \
		if (logger != KY_NULL && logger->IsInitialized())                                                        \
		{                                                                                                        \
			logger->StartNewMessage();                                                                           \
		}                                                                                                        \
	}                                                                                                            \
KY_MACRO_END

#endif // KY_WII


#define KY_ASSERTK(condition) KY_ASSERT(condition, ("Internal error, please contact Kynapse technical support"))

/*!	Sets the maximum number of messages that can be generated by the previous call to
	#KY_MESSAGE or #KY_COND_MESSAGE.
	\param maxCall						The maximum number of times the previous message can be sent.
	\pp For example: \code
	KY_FUNCTION("MyFunctionName");
	...
	KY_MESSAGE(KY_LOG_WARNING, ("Destination is outside partitions."));
	KY_MESSAGE_MAX_CALL(10); \endcode
	\ingroup kypathdata_basesystem */
#define KY_MESSAGE_MAX_CALL(maxCall) \
	Kaim::Logger::GetInstance()->SetLastMsgMaxCall(maxCall);

/*!	Sets the maximum number of messages that can be generated by the previous call to
	#KY_MESSAGE or #KY_COND_MESSAGE, and prints a warning message to indicate when the maximum
	number of occurrences has been reached.
	\param maxCall						The maximum number of times the previous message can be sent.
	\pp For example: \code
	KY_FUNCTION("MyFunctionName");
	...
	KY_MESSAGE(KY_LOG_WARNING, ("Destination is outside partitions."));
	KY_MESSAGE_MAX_CALL_WITH_WARNING(10); \endcode
	\ingroup kypathdata_basesystem */
#define KY_MESSAGE_MAX_CALL_WITH_WARNING(maxCall) \
	Kaim::Logger::GetInstance()->SetLastMsgMaxCallWithWarning(maxCall);

/*!	Provides a descriptive name for the current function or code block. You must
	include this macro in a function in order to log debug messages from your function, or
	in order to use the profiling framework to monitor the CPU usage of your function.
	\ingroup kypathdata_basesystem */
	//#ifdef KY_CALLSTACK_AUTO
	//	#define KY_FUNCTION(function) const char *s_KY_funcName = function; KY_LOG_MEMORY(s_KY_funcName)
	//#else // KY_CALLSTACK_AUTO
		#define KY_FUNCTION(function) const char *s_KY_funcName = function;
	//#endif // KY_CALLSTACK_AUTO

#else //KYDEBUG

#define KY_FUNCTION(function) {}
#define KY_MESSAGE(logLevel, args) {}
#define KY_ASSERT(condition, args) {}
#define KY_ASSERTK(condition) {}
#define KY_COND_MESSAGE(logLevel, condition, args) {}
#define KY_MESSAGE_MAX_CALL(maxCall){}
#define KY_MESSAGE_MAX_CALL_WITH_WARNING(maxCall){}

#endif //KYDEBUG

#define KY_FORWARD_ERROR(expression) { KyResult result = (expression); if (Kaim::Result::Fail(result)) { KY_MESSAGE(KY_LOG_ERROR, ("in : "#expression)); return result;} }



/*!	Generates a debugging message even when using the Release build.
	\param logLevel					Indicates the type of message to generate. May be any element from the 
									#LogLevel enumeration.
	\param args						The content of the message to generate. The message should be enclosed in
									parentheses, and may include variables using the standard C++ string
									printing syntax.
	\pp For example: \code
	KY_FUNCTION("MyFunctionName");
	...
	KY_RELEASE_MESSAGE(KY_LOG_ERROR, ("Could not open file [%s]", fileName));  \endcode
	\ingroup kypathdata_basesystem */
#ifdef KYDEBUG
	#define KY_RELEASE_MESSAGE(logLevel, args)                                              \
	KY_MACRO_START                                                                          \
		Kaim::Logger* logger = Kaim::Logger::GetInstance();                                 \
		if (logger != KY_NULL && logger->IsInitialized())                                   \
		{                                                                                   \
			logger->StartNewMessage();                                                      \
			static const KyUInt32 s_id = logger->ComputeMessageId(#args);                   \
			logger->CreateMessage args;                                                     \
			logger->Print(logLevel, s_id, __FILE__, __LINE__, s_KY_funcName);               \
		}                                                                                   \
	KY_MACRO_END
#else // !KYDEBUG...
	#define KY_RELEASE_MESSAGE(logLevel, args)                                              \
	KY_MACRO_START                                                                          \
		Kaim::Logger* logger = Kaim::Logger::GetInstance();                                       \
		if (logger != KY_NULL && logger->IsInitialized())                                   \
		{                                                                                   \
			logger->StartNewMessage();                                                      \
			logger->CreateMessage args;                                                     \
			logger->Print(logLevel, 0, __FILE__, __LINE__, "");                             \
		}                                                                                   \
	KY_MACRO_END
#endif // KYDEBUG

#else // !defined(__SPU__)

#define KY_FUNCTION(function) {}
#define KY_MESSAGE(logLevel, args) {}
#define KY_ASSERT(condition, args) {}
#define KY_ASSERTK(condition) {}
#define KY_COND_MESSAGE(logLevel, condition, args) {}
#define KY_MESSAGE_MAX_CALL(maxCall){}
#define KY_MESSAGE_MAX_CALL_WITH_WARNING(maxCall){}

#endif

#endif //KY_DEBUGLOGGER_H
